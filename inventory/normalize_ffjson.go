// DO NOT EDIT!
// Code generated by ffjson <https://github.com/pquerna/ffjson>
// source: normalize.go
// DO NOT EDIT!

package inventory

import (
	"bytes"
	"errors"
	"fmt"
	fflib "github.com/pquerna/ffjson/fflib/v1"
)

func (mj *NormalizedAction) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *NormalizedAction) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteString(`,"link":`)
	fflib.WriteJsonString(buf, string(mj.Link))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_NormalizedActionbase = iota
	ffj_t_NormalizedActionno_such_key

	ffj_t_NormalizedAction_Name

	ffj_t_NormalizedAction_Link
)

var ffj_key_NormalizedAction_Name = []byte("name")

var ffj_key_NormalizedAction_Link = []byte("link")

func (uj *NormalizedAction) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *NormalizedAction) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_NormalizedActionbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_NormalizedActionno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'l':

					if bytes.Equal(ffj_key_NormalizedAction_Link, kn) {
						currentKey = ffj_t_NormalizedAction_Link
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_NormalizedAction_Name, kn) {
						currentKey = ffj_t_NormalizedAction_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_NormalizedAction_Link, kn) {
					currentKey = ffj_t_NormalizedAction_Link
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_NormalizedAction_Name, kn) {
					currentKey = ffj_t_NormalizedAction_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_NormalizedActionno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_NormalizedAction_Name:
					goto handle_Name

				case ffj_t_NormalizedAction_Link:
					goto handle_Link

				case ffj_t_NormalizedActionno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Link:

	/* handler: uj.Link type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Link = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *NormalizedDescription) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *NormalizedDescription) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"value":`)
	fflib.WriteJsonString(buf, string(mj.Value))
	buf.WriteString(`,"type":`)
	fflib.WriteJsonString(buf, string(mj.Type))
	buf.WriteString(`,"color":`)
	fflib.WriteJsonString(buf, string(mj.Color))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_NormalizedDescriptionbase = iota
	ffj_t_NormalizedDescriptionno_such_key

	ffj_t_NormalizedDescription_Value

	ffj_t_NormalizedDescription_Type

	ffj_t_NormalizedDescription_Color
)

var ffj_key_NormalizedDescription_Value = []byte("value")

var ffj_key_NormalizedDescription_Type = []byte("type")

var ffj_key_NormalizedDescription_Color = []byte("color")

func (uj *NormalizedDescription) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *NormalizedDescription) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_NormalizedDescriptionbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_NormalizedDescriptionno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_NormalizedDescription_Color, kn) {
						currentKey = ffj_t_NormalizedDescription_Color
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_NormalizedDescription_Type, kn) {
						currentKey = ffj_t_NormalizedDescription_Type
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'v':

					if bytes.Equal(ffj_key_NormalizedDescription_Value, kn) {
						currentKey = ffj_t_NormalizedDescription_Value
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffj_key_NormalizedDescription_Color, kn) {
					currentKey = ffj_t_NormalizedDescription_Color
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_NormalizedDescription_Type, kn) {
					currentKey = ffj_t_NormalizedDescription_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_NormalizedDescription_Value, kn) {
					currentKey = ffj_t_NormalizedDescription_Value
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_NormalizedDescriptionno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_NormalizedDescription_Value:
					goto handle_Value

				case ffj_t_NormalizedDescription_Type:
					goto handle_Type

				case ffj_t_NormalizedDescription_Color:
					goto handle_Color

				case ffj_t_NormalizedDescriptionno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Value:

	/* handler: uj.Value type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Value = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: uj.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Color:

	/* handler: uj.Color type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Color = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *NormalizedInventory) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *NormalizedInventory) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"Items":`)
	if mj.Items != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Items {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_NormalizedInventorybase = iota
	ffj_t_NormalizedInventoryno_such_key

	ffj_t_NormalizedInventory_Items
)

var ffj_key_NormalizedInventory_Items = []byte("Items")

func (uj *NormalizedInventory) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *NormalizedInventory) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_NormalizedInventorybase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_NormalizedInventoryno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'I':

					if bytes.Equal(ffj_key_NormalizedInventory_Items, kn) {
						currentKey = ffj_t_NormalizedInventory_Items
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_NormalizedInventory_Items, kn) {
					currentKey = ffj_t_NormalizedInventory_Items
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_NormalizedInventoryno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_NormalizedInventory_Items:
					goto handle_Items

				case ffj_t_NormalizedInventoryno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Items:

	/* handler: uj.Items type=[]inventory.NormalizedItem kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Items = nil
		} else {

			uj.Items = make([]NormalizedItem, 0)

			wantVal := true

			for {

				var tmp_uj__Items NormalizedItem

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__Items type=inventory.NormalizedItem kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__Items.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Items = append(uj.Items, tmp_uj__Items)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *NormalizedItem) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *NormalizedItem) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"app_id":`)
	fflib.FormatBits2(buf, uint64(mj.AppID), 10, false)
	buf.WriteString(`,"id":`)
	fflib.FormatBits2(buf, uint64(mj.ID), 10, false)
	buf.WriteString(`,"class_id":`)
	fflib.FormatBits2(buf, uint64(mj.ClassID), 10, false)
	buf.WriteString(`,"instance_id":`)
	fflib.FormatBits2(buf, uint64(mj.InstanceID), 10, false)
	buf.WriteString(`,"amount":`)
	fflib.FormatBits2(buf, uint64(mj.Amount), 10, false)
	buf.WriteString(`,"pos":`)
	fflib.FormatBits2(buf, uint64(mj.Pos), 10, false)
	buf.WriteString(`,"icon_url":`)
	fflib.WriteJsonString(buf, string(mj.IconURL))
	buf.WriteString(`,"icon_url_large":`)
	fflib.WriteJsonString(buf, string(mj.IconURLLarge))
	buf.WriteString(`,"icon_drag_url":`)
	fflib.WriteJsonString(buf, string(mj.IconDragURL))
	buf.WriteString(`,"name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteString(`,"market_name":`)
	fflib.WriteJsonString(buf, string(mj.MarketName))
	buf.WriteString(`,"market_hash_name":`)
	fflib.WriteJsonString(buf, string(mj.MarketHashName))
	buf.WriteString(`,"name_color":`)
	fflib.WriteJsonString(buf, string(mj.NameColor))
	buf.WriteString(`,"background_color":`)
	fflib.WriteJsonString(buf, string(mj.BackgroundColor))
	buf.WriteString(`,"type":`)
	fflib.WriteJsonString(buf, string(mj.Type))
	if mj.Tradable {
		buf.WriteString(`,"tradable":true`)
	} else {
		buf.WriteString(`,"tradable":false`)
	}
	if mj.Marketable {
		buf.WriteString(`,"marketable":true`)
	} else {
		buf.WriteString(`,"marketable":false`)
	}
	if mj.Commodity {
		buf.WriteString(`,"commodity":true`)
	} else {
		buf.WriteString(`,"commodity":false`)
	}
	buf.WriteString(`,"market_tradable_restriction":`)
	fflib.FormatBits2(buf, uint64(mj.MarketTradableRestriction), 10, false)
	buf.WriteString(`,"descriptions":`)
	if mj.Descriptions != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Descriptions {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"actions":`)
	if mj.Actions != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Actions {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	if mj.AppData == nil {
		buf.WriteString(`,"appdata":null`)
	} else {
		buf.WriteString(`,"appdata":{ `)
		for key, value := range mj.AppData {
			fflib.WriteJsonString(buf, key)
			buf.WriteString(`:`)
			fflib.WriteJsonString(buf, string(value))
			buf.WriteByte(',')
		}
		buf.Rewind(1)
		buf.WriteByte('}')
	}
	buf.WriteString(`,"tags":`)
	if mj.Tags != nil {
		buf.WriteString(`[`)
		for i, v := range mj.Tags {
			if i != 0 {
				buf.WriteString(`,`)
			}

			{

				err = v.MarshalJSONBuf(buf)
				if err != nil {
					return err
				}

			}
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_NormalizedItembase = iota
	ffj_t_NormalizedItemno_such_key

	ffj_t_NormalizedItem_AppID

	ffj_t_NormalizedItem_ID

	ffj_t_NormalizedItem_ClassID

	ffj_t_NormalizedItem_InstanceID

	ffj_t_NormalizedItem_Amount

	ffj_t_NormalizedItem_Pos

	ffj_t_NormalizedItem_IconURL

	ffj_t_NormalizedItem_IconURLLarge

	ffj_t_NormalizedItem_IconDragURL

	ffj_t_NormalizedItem_Name

	ffj_t_NormalizedItem_MarketName

	ffj_t_NormalizedItem_MarketHashName

	ffj_t_NormalizedItem_NameColor

	ffj_t_NormalizedItem_BackgroundColor

	ffj_t_NormalizedItem_Type

	ffj_t_NormalizedItem_Tradable

	ffj_t_NormalizedItem_Marketable

	ffj_t_NormalizedItem_Commodity

	ffj_t_NormalizedItem_MarketTradableRestriction

	ffj_t_NormalizedItem_Descriptions

	ffj_t_NormalizedItem_Actions

	ffj_t_NormalizedItem_AppData

	ffj_t_NormalizedItem_Tags
)

var ffj_key_NormalizedItem_AppID = []byte("app_id")

var ffj_key_NormalizedItem_ID = []byte("id")

var ffj_key_NormalizedItem_ClassID = []byte("class_id")

var ffj_key_NormalizedItem_InstanceID = []byte("instance_id")

var ffj_key_NormalizedItem_Amount = []byte("amount")

var ffj_key_NormalizedItem_Pos = []byte("pos")

var ffj_key_NormalizedItem_IconURL = []byte("icon_url")

var ffj_key_NormalizedItem_IconURLLarge = []byte("icon_url_large")

var ffj_key_NormalizedItem_IconDragURL = []byte("icon_drag_url")

var ffj_key_NormalizedItem_Name = []byte("name")

var ffj_key_NormalizedItem_MarketName = []byte("market_name")

var ffj_key_NormalizedItem_MarketHashName = []byte("market_hash_name")

var ffj_key_NormalizedItem_NameColor = []byte("name_color")

var ffj_key_NormalizedItem_BackgroundColor = []byte("background_color")

var ffj_key_NormalizedItem_Type = []byte("type")

var ffj_key_NormalizedItem_Tradable = []byte("tradable")

var ffj_key_NormalizedItem_Marketable = []byte("marketable")

var ffj_key_NormalizedItem_Commodity = []byte("commodity")

var ffj_key_NormalizedItem_MarketTradableRestriction = []byte("market_tradable_restriction")

var ffj_key_NormalizedItem_Descriptions = []byte("descriptions")

var ffj_key_NormalizedItem_Actions = []byte("actions")

var ffj_key_NormalizedItem_AppData = []byte("appdata")

var ffj_key_NormalizedItem_Tags = []byte("tags")

func (uj *NormalizedItem) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *NormalizedItem) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_NormalizedItembase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_NormalizedItemno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'a':

					if bytes.Equal(ffj_key_NormalizedItem_AppID, kn) {
						currentKey = ffj_t_NormalizedItem_AppID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_NormalizedItem_Amount, kn) {
						currentKey = ffj_t_NormalizedItem_Amount
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_NormalizedItem_Actions, kn) {
						currentKey = ffj_t_NormalizedItem_Actions
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_NormalizedItem_AppData, kn) {
						currentKey = ffj_t_NormalizedItem_AppData
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'b':

					if bytes.Equal(ffj_key_NormalizedItem_BackgroundColor, kn) {
						currentKey = ffj_t_NormalizedItem_BackgroundColor
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffj_key_NormalizedItem_ClassID, kn) {
						currentKey = ffj_t_NormalizedItem_ClassID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_NormalizedItem_Commodity, kn) {
						currentKey = ffj_t_NormalizedItem_Commodity
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffj_key_NormalizedItem_Descriptions, kn) {
						currentKey = ffj_t_NormalizedItem_Descriptions
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_NormalizedItem_ID, kn) {
						currentKey = ffj_t_NormalizedItem_ID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_NormalizedItem_InstanceID, kn) {
						currentKey = ffj_t_NormalizedItem_InstanceID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_NormalizedItem_IconURL, kn) {
						currentKey = ffj_t_NormalizedItem_IconURL
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_NormalizedItem_IconURLLarge, kn) {
						currentKey = ffj_t_NormalizedItem_IconURLLarge
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_NormalizedItem_IconDragURL, kn) {
						currentKey = ffj_t_NormalizedItem_IconDragURL
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffj_key_NormalizedItem_MarketName, kn) {
						currentKey = ffj_t_NormalizedItem_MarketName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_NormalizedItem_MarketHashName, kn) {
						currentKey = ffj_t_NormalizedItem_MarketHashName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_NormalizedItem_Marketable, kn) {
						currentKey = ffj_t_NormalizedItem_Marketable
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_NormalizedItem_MarketTradableRestriction, kn) {
						currentKey = ffj_t_NormalizedItem_MarketTradableRestriction
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_NormalizedItem_Name, kn) {
						currentKey = ffj_t_NormalizedItem_Name
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_NormalizedItem_NameColor, kn) {
						currentKey = ffj_t_NormalizedItem_NameColor
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffj_key_NormalizedItem_Pos, kn) {
						currentKey = ffj_t_NormalizedItem_Pos
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 't':

					if bytes.Equal(ffj_key_NormalizedItem_Type, kn) {
						currentKey = ffj_t_NormalizedItem_Type
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_NormalizedItem_Tradable, kn) {
						currentKey = ffj_t_NormalizedItem_Tradable
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_NormalizedItem_Tags, kn) {
						currentKey = ffj_t_NormalizedItem_Tags
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffj_key_NormalizedItem_Tags, kn) {
					currentKey = ffj_t_NormalizedItem_Tags
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_NormalizedItem_AppData, kn) {
					currentKey = ffj_t_NormalizedItem_AppData
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NormalizedItem_Actions, kn) {
					currentKey = ffj_t_NormalizedItem_Actions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NormalizedItem_Descriptions, kn) {
					currentKey = ffj_t_NormalizedItem_Descriptions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NormalizedItem_MarketTradableRestriction, kn) {
					currentKey = ffj_t_NormalizedItem_MarketTradableRestriction
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_NormalizedItem_Commodity, kn) {
					currentKey = ffj_t_NormalizedItem_Commodity
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NormalizedItem_Marketable, kn) {
					currentKey = ffj_t_NormalizedItem_Marketable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_NormalizedItem_Tradable, kn) {
					currentKey = ffj_t_NormalizedItem_Tradable
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_NormalizedItem_Type, kn) {
					currentKey = ffj_t_NormalizedItem_Type
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NormalizedItem_BackgroundColor, kn) {
					currentKey = ffj_t_NormalizedItem_BackgroundColor
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_NormalizedItem_NameColor, kn) {
					currentKey = ffj_t_NormalizedItem_NameColor
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NormalizedItem_MarketHashName, kn) {
					currentKey = ffj_t_NormalizedItem_MarketHashName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NormalizedItem_MarketName, kn) {
					currentKey = ffj_t_NormalizedItem_MarketName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_NormalizedItem_Name, kn) {
					currentKey = ffj_t_NormalizedItem_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_NormalizedItem_IconDragURL, kn) {
					currentKey = ffj_t_NormalizedItem_IconDragURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_NormalizedItem_IconURLLarge, kn) {
					currentKey = ffj_t_NormalizedItem_IconURLLarge
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_NormalizedItem_IconURL, kn) {
					currentKey = ffj_t_NormalizedItem_IconURL
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NormalizedItem_Pos, kn) {
					currentKey = ffj_t_NormalizedItem_Pos
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_NormalizedItem_Amount, kn) {
					currentKey = ffj_t_NormalizedItem_Amount
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NormalizedItem_InstanceID, kn) {
					currentKey = ffj_t_NormalizedItem_InstanceID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffj_key_NormalizedItem_ClassID, kn) {
					currentKey = ffj_t_NormalizedItem_ClassID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_NormalizedItem_ID, kn) {
					currentKey = ffj_t_NormalizedItem_ID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_NormalizedItem_AppID, kn) {
					currentKey = ffj_t_NormalizedItem_AppID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_NormalizedItemno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_NormalizedItem_AppID:
					goto handle_AppID

				case ffj_t_NormalizedItem_ID:
					goto handle_ID

				case ffj_t_NormalizedItem_ClassID:
					goto handle_ClassID

				case ffj_t_NormalizedItem_InstanceID:
					goto handle_InstanceID

				case ffj_t_NormalizedItem_Amount:
					goto handle_Amount

				case ffj_t_NormalizedItem_Pos:
					goto handle_Pos

				case ffj_t_NormalizedItem_IconURL:
					goto handle_IconURL

				case ffj_t_NormalizedItem_IconURLLarge:
					goto handle_IconURLLarge

				case ffj_t_NormalizedItem_IconDragURL:
					goto handle_IconDragURL

				case ffj_t_NormalizedItem_Name:
					goto handle_Name

				case ffj_t_NormalizedItem_MarketName:
					goto handle_MarketName

				case ffj_t_NormalizedItem_MarketHashName:
					goto handle_MarketHashName

				case ffj_t_NormalizedItem_NameColor:
					goto handle_NameColor

				case ffj_t_NormalizedItem_BackgroundColor:
					goto handle_BackgroundColor

				case ffj_t_NormalizedItem_Type:
					goto handle_Type

				case ffj_t_NormalizedItem_Tradable:
					goto handle_Tradable

				case ffj_t_NormalizedItem_Marketable:
					goto handle_Marketable

				case ffj_t_NormalizedItem_Commodity:
					goto handle_Commodity

				case ffj_t_NormalizedItem_MarketTradableRestriction:
					goto handle_MarketTradableRestriction

				case ffj_t_NormalizedItem_Descriptions:
					goto handle_Descriptions

				case ffj_t_NormalizedItem_Actions:
					goto handle_Actions

				case ffj_t_NormalizedItem_AppData:
					goto handle_AppData

				case ffj_t_NormalizedItem_Tags:
					goto handle_Tags

				case ffj_t_NormalizedItemno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_AppID:

	/* handler: uj.AppID type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.AppID = uint32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: uj.ID type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ID = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ClassID:

	/* handler: uj.ClassID type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.ClassID = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_InstanceID:

	/* handler: uj.InstanceID type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.InstanceID = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Amount:

	/* handler: uj.Amount type=uint64 kind=uint64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Amount = uint64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Pos:

	/* handler: uj.Pos type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.Pos = uint32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IconURL:

	/* handler: uj.IconURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.IconURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IconURLLarge:

	/* handler: uj.IconURLLarge type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.IconURLLarge = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IconDragURL:

	/* handler: uj.IconDragURL type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.IconDragURL = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MarketName:

	/* handler: uj.MarketName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.MarketName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MarketHashName:

	/* handler: uj.MarketHashName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.MarketHashName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NameColor:

	/* handler: uj.NameColor type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.NameColor = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BackgroundColor:

	/* handler: uj.BackgroundColor type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.BackgroundColor = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Type:

	/* handler: uj.Type type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Type = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tradable:

	/* handler: uj.Tradable type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Tradable = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Tradable = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Marketable:

	/* handler: uj.Marketable type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Marketable = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Marketable = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Commodity:

	/* handler: uj.Commodity type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				uj.Commodity = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				uj.Commodity = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MarketTradableRestriction:

	/* handler: uj.MarketTradableRestriction type=uint32 kind=uint32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			uj.MarketTradableRestriction = uint32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Descriptions:

	/* handler: uj.Descriptions type=[]inventory.NormalizedDescription kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Descriptions = nil
		} else {

			uj.Descriptions = make([]NormalizedDescription, 0)

			wantVal := true

			for {

				var tmp_uj__Descriptions NormalizedDescription

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__Descriptions type=inventory.NormalizedDescription kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__Descriptions.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Descriptions = append(uj.Descriptions, tmp_uj__Descriptions)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Actions:

	/* handler: uj.Actions type=[]inventory.NormalizedAction kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Actions = nil
		} else {

			uj.Actions = make([]NormalizedAction, 0)

			wantVal := true

			for {

				var tmp_uj__Actions NormalizedAction

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__Actions type=inventory.NormalizedAction kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__Actions.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Actions = append(uj.Actions, tmp_uj__Actions)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_AppData:

	/* handler: uj.AppData type=map[string]string kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.AppData = nil
		} else {

			uj.AppData = make(map[string]string, 0)

			wantVal := true

			for {

				var k string

				var tmp_uj__AppData string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmp_uj__AppData type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmp_uj__AppData = string(string(outBuf))

					}
				}

				uj.AppData[k] = tmp_uj__AppData

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Tags:

	/* handler: uj.Tags type=[]inventory.NormalizedTag kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			uj.Tags = nil
		} else {

			uj.Tags = make([]NormalizedTag, 0)

			wantVal := true

			for {

				var tmp_uj__Tags NormalizedTag

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmp_uj__Tags type=inventory.NormalizedTag kind=struct quoted=false*/

				{
					if tok == fflib.FFTok_null {

						state = fflib.FFParse_after_value
						goto mainparse
					}

					err = tmp_uj__Tags.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
					if err != nil {
						return err
					}
					state = fflib.FFParse_after_value
				}

				uj.Tags = append(uj.Tags, tmp_uj__Tags)
				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}

func (mj *NormalizedTag) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if mj == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := mj.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
func (mj *NormalizedTag) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if mj == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"internal_name":`)
	fflib.WriteJsonString(buf, string(mj.InternalName))
	buf.WriteString(`,"name":`)
	fflib.WriteJsonString(buf, string(mj.Name))
	buf.WriteString(`,"category":`)
	fflib.WriteJsonString(buf, string(mj.Category))
	buf.WriteString(`,"category_name":`)
	fflib.WriteJsonString(buf, string(mj.CategoryName))
	buf.WriteByte('}')
	return nil
}

const (
	ffj_t_NormalizedTagbase = iota
	ffj_t_NormalizedTagno_such_key

	ffj_t_NormalizedTag_InternalName

	ffj_t_NormalizedTag_Name

	ffj_t_NormalizedTag_Category

	ffj_t_NormalizedTag_CategoryName
)

var ffj_key_NormalizedTag_InternalName = []byte("internal_name")

var ffj_key_NormalizedTag_Name = []byte("name")

var ffj_key_NormalizedTag_Category = []byte("category")

var ffj_key_NormalizedTag_CategoryName = []byte("category_name")

func (uj *NormalizedTag) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return uj.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

func (uj *NormalizedTag) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error = nil
	currentKey := ffj_t_NormalizedTagbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffj_t_NormalizedTagno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffj_key_NormalizedTag_Category, kn) {
						currentKey = ffj_t_NormalizedTag_Category
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffj_key_NormalizedTag_CategoryName, kn) {
						currentKey = ffj_t_NormalizedTag_CategoryName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffj_key_NormalizedTag_InternalName, kn) {
						currentKey = ffj_t_NormalizedTag_InternalName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffj_key_NormalizedTag_Name, kn) {
						currentKey = ffj_t_NormalizedTag_Name
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.AsciiEqualFold(ffj_key_NormalizedTag_CategoryName, kn) {
					currentKey = ffj_t_NormalizedTag_CategoryName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_NormalizedTag_Category, kn) {
					currentKey = ffj_t_NormalizedTag_Category
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffj_key_NormalizedTag_Name, kn) {
					currentKey = ffj_t_NormalizedTag_Name
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.AsciiEqualFold(ffj_key_NormalizedTag_InternalName, kn) {
					currentKey = ffj_t_NormalizedTag_InternalName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffj_t_NormalizedTagno_such_key
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffj_t_NormalizedTag_InternalName:
					goto handle_InternalName

				case ffj_t_NormalizedTag_Name:
					goto handle_Name

				case ffj_t_NormalizedTag_Category:
					goto handle_Category

				case ffj_t_NormalizedTag_CategoryName:
					goto handle_CategoryName

				case ffj_t_NormalizedTagno_such_key:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_InternalName:

	/* handler: uj.InternalName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.InternalName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: uj.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Category:

	/* handler: uj.Category type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.Category = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CategoryName:

	/* handler: uj.CategoryName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			uj.CategoryName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:
	return nil
}
